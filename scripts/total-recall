#!/usr/bin/env bash
set -euo pipefail

# Ensure bun-installed globals (like qmd) are on PATH
for p in "$HOME/.bun/bin" "/opt/homebrew/bin" "/usr/local/bin"; do
  [[ -d "$p" ]] && [[ ":$PATH:" != *":$p:"* ]] && export PATH="$p:$PATH"
done

DEFAULT_SHARED_ROOT="${TOTAL_RECALL_SHARED_ROOT:-$HOME/.ai-memory/knowledge}"
DEFAULT_CLAUDE_HOME="${CLAUDE_HOME:-$HOME/.claude}"
DEFAULT_CODEX_HOME="${CODEX_HOME:-$HOME/.codex}"
DEFAULT_ICLOUD_ROOT="${TOTAL_RECALL_ICLOUD_ROOT:-$HOME/Library/Mobile Documents/com~apple~CloudDocs/AI-Memory/knowledge}"
DEFAULT_STATE_ROOT="${TOTAL_RECALL_STATE_ROOT:-$HOME/.ai-memory/state}"
DEFAULT_LAUNCH_INTERVAL_MINUTES="${TOTAL_RECALL_SYNC_INTERVAL_MINUTES:-15}"

usage() {
  cat <<'EOF'
total-recall: persistent cross-session memory for Claude Code and Codex

Usage:
  total-recall write "<summary>" [--project NAME]
  total-recall query "<query>" [--project NAME]
  total-recall install [--project NAME] [options]
  total-recall status [--project NAME]
  total-recall ingest [--project NAME]
  total-recall server {init|start|stop|status|add-key|install-launchd}
  total-recall client {configure --server-url URL --api-key KEY|status|disable|enable}

Project name is auto-detected from the git remote origin (deterministic across
machines). Use --project to override.

Install modes:
  Standalone (default):
    total-recall install [--project NAME]
    Sets up local memory, hooks, ingestion, iCloud backup, and background sync.

  Server (host memory for multiple machines):
    total-recall install --server [--project NAME] [--port PORT]
    Full local setup + starts HTTP server with web UI + auto-start on boot.
    Prints API key and connection instructions for client machines.

  Client (connect to a remote server):
    total-recall install --client --server-url URL --api-key KEY [--project NAME]
    Lightweight setup: hooks + instruction injection only. No local qmd needed.
    All write/query operations route to the server automatically.

Install options:
  --project NAME         Project name (default: auto-detected from git remote)
  --server               Server mode: also starts HTTP API + web UI
  --client               Client mode: connect to remote server (no local qmd)
  --server-url URL       Server URL (required with --client)
  --api-key KEY          API key (required with --client)
  --port PORT            Server port (default: 7899, only with --server)
  --no-icloud            Skip iCloud backup
  --no-launch-agent      Skip background sync agent
  --interval-minutes N   Background sync interval (default: 15)
  --skip-embed           Skip vector embeddings during setup

Other commands:
  setup      Link dirs + configure qmd (no ingestion)
  ingest     Import Claude/Codex session logs
  icloud-enable/sync/status   Manage iCloud backup

Environment variables:
  TOTAL_RECALL_SERVER_URL   Override client server URL
  TOTAL_RECALL_API_KEY      Override client API key
  TOTAL_RECALL_QUERY_TOKEN_BUDGET  Token budget for optimized query output (default: 900)
  TOTAL_RECALL_QUERY_RAW    Set to 1 to return raw qmd output without optimization
  TOTAL_RECALL_QUERY_MIN_RESULTS  Minimum primary query hits before expanding retrieval (default: 4)
  TOTAL_RECALL_QMD_INDEX_PREFIX  Prefix for per-project qmd index names (default: total-recall)
EOF
}

die() {
  echo "Error: $*" >&2
  exit 1
}

require_cmd() {
  command -v "$1" >/dev/null 2>&1 || die "Missing required command: $1"
}

abs_realpath() {
  python3 - "$1" <<'PY'
import os, sys
print(os.path.realpath(os.path.expanduser(sys.argv[1])))
PY
}

resolve_link_target() {
  python3 - "$1" <<'PY'
import os
import sys

link_path = os.path.expanduser(sys.argv[1])
if not os.path.islink(link_path):
    print("")
    raise SystemExit(0)

target = os.readlink(link_path)
if os.path.isabs(target):
    print(os.path.realpath(target))
else:
    print(os.path.realpath(os.path.join(os.path.dirname(link_path), target)))
PY
}

slugify() {
  local raw="$1"
  local out
  out="$(printf '%s' "$raw" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9]+/-/g; s/^-+//; s/-+$//; s/-+/-/g')"
  if [[ -z "$out" ]]; then
    out="memory"
  fi
  printf '%s' "$out"
}

qmd_index_name() {
  local project_name="$1"
  local prefix
  prefix="$(slugify "${TOTAL_RECALL_QMD_INDEX_PREFIX:-total-recall}")"
  printf '%s-%s' "$prefix" "$(slugify "$project_name")"
}

qmd_cmd() {
  local project_name="$1"
  shift
  qmd --index "$(qmd_index_name "$project_name")" "$@"
}

machine_id() {
  local name
  name="$(scutil --get ComputerName 2>/dev/null)" && [[ -n "$name" ]] && { printf '%s' "$name"; return; }
  name="$(hostname -s 2>/dev/null)" && [[ -n "$name" ]] && { printf '%s' "$name"; return; }
  hostname 2>/dev/null || echo "unknown"
}

is_remote_configured() {
  [[ -n "${TOTAL_RECALL_SERVER_URL:-}" ]] && return 0
  local config="$HOME/.ai-memory/client.json"
  [[ -f "$config" ]] || return 1
  local url
  url="$(python3 -c "import json; print(json.load(open('$config')).get('server_url',''))" 2>/dev/null)"
  [[ -n "$url" ]] && return 0
  return 1
}

get_remote_url() {
  if [[ -n "${TOTAL_RECALL_SERVER_URL:-}" ]]; then
    printf '%s' "$TOTAL_RECALL_SERVER_URL"
    return
  fi
  python3 -c "import json; print(json.load(open('$HOME/.ai-memory/client.json')).get('server_url',''))" 2>/dev/null
}

get_api_key() {
  if [[ -n "${TOTAL_RECALL_API_KEY:-}" ]]; then
    printf '%s' "$TOTAL_RECALL_API_KEY"
    return
  fi
  python3 -c "import json; print(json.load(open('$HOME/.ai-memory/client.json')).get('api_key',''))" 2>/dev/null
}

get_machine_id_from_config() {
  python3 -c "import json; print(json.load(open('$HOME/.ai-memory/client.json')).get('machine_id',''))" 2>/dev/null
}

remote_post() {
  local endpoint="$1"
  local body="$2"
  local url api_key
  url="$(get_remote_url)"
  api_key="$(get_api_key)"
  curl -sf --max-time 15 \
    -X POST \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer $api_key" \
    -d "$body" \
    "${url}${endpoint}"
}

derive_project_name() {
  local explicit="$1"
  if [[ -n "$explicit" ]]; then
    printf '%s' "$(slugify "$explicit")"
    return
  fi

  local remote repo
  if remote="$(git -C "$PWD" remote get-url origin 2>/dev/null)"; then
    repo="$(basename "$remote")"
    repo="${repo%.git}"
    printf '%s' "$(slugify "$repo")"
    return
  fi

  printf '%s' "$(slugify "$(basename "$PWD")")"
}

safe_mkdir() {
  mkdir -p "$1"
}

require_icloud_drive() {
  local drive="$HOME/Library/Mobile Documents/com~apple~CloudDocs"
  [[ -d "$drive" ]] || die "iCloud Drive not found at $drive (enable iCloud Drive first)"
}

backup_name() {
  local path="$1"
  printf '%s.backup.%s' "$path" "$(date +%Y%m%d%H%M%S)"
}

sync_dirs_ignore_existing() {
  local src="$1"
  local dst="$2"
  require_cmd rsync
  safe_mkdir "$dst"
  rsync -a --ignore-existing "$src/" "$dst/"
}

sync_dirs_mirror() {
  local src="$1"
  local dst="$2"
  require_cmd rsync
  safe_mkdir "$dst"
  rsync -a --delete "$src/" "$dst/"
}

script_dir() {
  python3 - "${BASH_SOURCE[0]}" <<'PY'
import os, sys
print(os.path.dirname(os.path.realpath(sys.argv[1])))
PY
}

script_path() {
  abs_realpath "${BASH_SOURCE[0]}"
}

canonical_cli_path() {
  # The stable, predictable path that survives repo moves and plugin reinstalls.
  # cmd_install() ensures this symlink always points to the real script.
  printf '%s' "$HOME/.local/bin/total-recall"
}

upsert_markdown_block() {
  local file_path="$1"
  local start_marker="$2"
  local end_marker="$3"
  local block_content="$4"
  safe_mkdir "$(dirname "$file_path")"

  python3 - "$file_path" "$start_marker" "$end_marker" "$block_content" <<'PY'
import os
import re
import sys

path, start, end, block = sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4]
os.makedirs(os.path.dirname(os.path.expanduser(path)), exist_ok=True)
full = f"{start}\n{block}\n{end}"

if os.path.exists(path):
    with open(path, "r", encoding="utf-8") as f:
        original = f.read()
else:
    original = ""

pattern = re.compile(re.escape(start) + r".*?" + re.escape(end), re.S)
if pattern.search(original):
    updated = pattern.sub(full, original)
else:
    if original and not original.endswith("\n"):
        original += "\n"
    if original:
        updated = original + "\n" + full + "\n"
    else:
        updated = full + "\n"

with open(path, "w", encoding="utf-8") as f:
    f.write(updated)
PY
}

install_instruction_blocks() {
  local project_name="$1"  # kept for backward compat; not used in generated text
  local shared_root="$2"
  local cli_path="$3"
  local claude_file="$DEFAULT_CLAUDE_HOME/CLAUDE.md"
  local codex_file="$DEFAULT_CODEX_HOME/AGENTS.md"
  local start_marker="<!-- total-recall:auto:start -->"
  local end_marker="<!-- total-recall:auto:end -->"

  # Universal block — no hardcoded project name. The CLI auto-derives
  # the project from the git remote origin (deterministic across machines).
  local block
  block="## Total Recall Auto-Memory (total-recall)

### MANDATORY — your FIRST action every session
Before reading files, before planning, before responding to the user request —
run this command to load context from prior sessions:
\`\`\`
$cli_path query \"<what the user is asking about>\"
\`\`\`
This is not optional. Skipping it means you will repeat past mistakes, re-explore
already-investigated code, and miss decisions that were already made. The query
takes seconds but saves entire conversations of wasted work.

### MANDATORY — after completing non-trivial work
When you finish implementing a feature, fixing a bug, making a design decision,
or learning something that would help a future session, persist it:
\`\`\`
$cli_path write \"<concise summary: what changed, why, and what you learned>\"
\`\`\`

### MANDATORY — before your final response in non-trivial sessions
If you changed files, ran meaningful commands, made implementation decisions,
or diagnosed a bug, run the write command before responding to the user:
\`\`\`
$cli_path write \"<concise summary: what changed, why, and what you learned>\"
\`\`\`
Do not ask the user to run this command.

### When to query mid-session
- Before choosing between multiple valid approaches (prior sessions may have already tried one)
- When you hit an unexpected error (it may have been solved before)
- When the user references something from a previous session

### When NOT to query
- You already queried at session start and are mid-task with full context
- The task is trivial (fixing a typo, adding a log statement)
- The user gave you everything you need in their message

### When NOT to write
- The session was truly trivial (read-only exploration, no decisions, no meaningful changes)
- You already wrote a memory note for this exact completed work

Do NOT tell the user to run these commands manually. This is YOUR responsibility."

  upsert_markdown_block "$claude_file" "$start_marker" "$end_marker" "$block"
  upsert_markdown_block "$codex_file" "$start_marker" "$end_marker" "$block"
}

install_launch_agent() {
  local project_name="$1"
  local shared_root="$2"
  local cli_path="$3"
  local interval_minutes="$4"
  local interval_seconds
  interval_seconds=$((interval_minutes * 60))
  local uid
  uid="$(id -u)"

  local label="com.totalrecall.sync.$project_name"
  local launch_dir="$HOME/Library/LaunchAgents"
  local log_dir="$HOME/.ai-memory/logs"
  local plist="$launch_dir/$label.plist"
  local stdout_log="$log_dir/$project_name-sync.out.log"
  local stderr_log="$log_dir/$project_name-sync.err.log"
  safe_mkdir "$launch_dir"
  safe_mkdir "$log_dir"

  if ! command -v launchctl >/dev/null 2>&1; then
    echo "launchctl not found; skipped launch agent install."
    return
  fi

  python3 - "$plist" "$label" "$cli_path" "$project_name" "$shared_root" "$stdout_log" "$stderr_log" "$interval_seconds" <<'PY'
import plistlib
import sys
from pathlib import Path

plist_path, label, cli, project, shared_root, stdout_log, stderr_log, interval_seconds = sys.argv[1:]
interval = int(interval_seconds)
cmd = (
    'export PATH="$HOME/.bun/bin:/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"; '
    f'"{cli}" ingest --project "{project}" --shared-root "{shared_root}"'
)

payload = {
    "Label": label,
    "ProgramArguments": ["/bin/bash", "-lc", cmd],
    "RunAtLoad": True,
    "StartInterval": interval,
    "StandardOutPath": stdout_log,
    "StandardErrorPath": stderr_log,
    "ProcessType": "Background",
}

Path(plist_path).parent.mkdir(parents=True, exist_ok=True)
with open(plist_path, "wb") as f:
    plistlib.dump(payload, f)
PY

  launchctl bootout "gui/$uid/$label" >/dev/null 2>&1 || true
  if ! launchctl bootstrap "gui/$uid" "$plist" >/dev/null 2>&1; then
    launchctl load -w "$plist" >/dev/null 2>&1 || true
  fi
  launchctl kickstart -k "gui/$uid/$label" >/dev/null 2>&1 || true

  echo "Installed launch agent: $label (every ${interval_minutes}m)"
  echo "Logs:"
  echo "  $stdout_log"
  echo "  $stderr_log"
}

merge_into_dir_if_present() {
  local src="$1"
  local dst="$2"

  if [[ -d "$src" ]]; then
    sync_dirs_ignore_existing "$src" "$dst"
  fi
}

link_to_shared() {
  local link_path="$1"
  local shared_target="$2"

  safe_mkdir "$(dirname "$link_path")"

  if [[ -L "$link_path" ]]; then
    local resolved_current resolved_target
    resolved_current="$(resolve_link_target "$link_path")"
    resolved_target="$(abs_realpath "$shared_target")"
    if [[ "$resolved_current" == "$resolved_target" ]]; then
      return
    fi
    rm -f "$link_path"
  elif [[ -e "$link_path" ]]; then
    merge_into_dir_if_present "$link_path" "$shared_target"
    local backup
    backup="$(backup_name "$link_path")"
    mv "$link_path" "$backup"
    echo "Backed up $link_path -> $backup"
  fi

  ln -s "$shared_target" "$link_path"
}

ensure_claude_settings() {
  local claude_settings="$1"
  safe_mkdir "$(dirname "$claude_settings")"

  python3 - "$claude_settings" <<'PY'
import json
import os
import sys

path = os.path.expanduser(sys.argv[1])
data = {}
if os.path.exists(path):
    with open(path, "r", encoding="utf-8") as f:
        txt = f.read().strip()
    if txt:
        data = json.loads(txt)

if not isinstance(data, dict):
    raise SystemExit("~/.claude/settings.json must contain a JSON object")

mcp = data.setdefault("mcpServers", {})
if not isinstance(mcp, dict):
    mcp = {}
    data["mcpServers"] = mcp

mcp["qmd"] = {"command": "qmd", "args": ["mcp"]}

allowed = data.setdefault("allowedTools", [])
if not isinstance(allowed, list):
    allowed = []
    data["allowedTools"] = allowed
if "Bash(qmd *)" not in allowed:
    allowed.append("Bash(qmd *)")

with open(path, "w", encoding="utf-8") as f:
    json.dump(data, f, indent=2)
    f.write("\n")
PY
}

ensure_codex_settings() {
  local codex_config="$1"
  safe_mkdir "$(dirname "$codex_config")"

  if [[ ! -f "$codex_config" ]]; then
    cat >"$codex_config" <<'EOF'
[mcp_servers.qmd]
command = "qmd"
args = ["mcp"]
EOF
    return
  fi

  if grep -Eq '^\[mcp_servers\.qmd\]' "$codex_config"; then
    return
  fi

  {
    echo ""
    echo "[mcp_servers.qmd]"
    echo 'command = "qmd"'
    echo 'args = ["mcp"]'
  } >>"$codex_config"
}

ensure_collection() {
  local collection_name="$1"
  local shared_project_dir="$2"
  local project_name="$3"
  local skip_embed="$4"
  local canonical_dir

  require_cmd qmd
  canonical_dir="$(abs_realpath "$shared_project_dir")"

  if ! qmd_cmd "$project_name" ls "$collection_name" >/dev/null 2>&1; then
    qmd_cmd "$project_name" collection add "$canonical_dir" --name "$collection_name" --mask "**/*.md"
  fi

  if ! qmd_cmd "$project_name" context list 2>/dev/null | grep -Fq "$canonical_dir"; then
    if ! qmd_cmd "$project_name" context add "$canonical_dir" "Shared Claude + Codex memory for project $project_name" >/dev/null 2>&1; then
      qmd_cmd "$project_name" collection remove "$collection_name" >/dev/null 2>&1 || true
      qmd_cmd "$project_name" collection add "$canonical_dir" --name "$collection_name" --mask "**/*.md"
      qmd_cmd "$project_name" context add "$canonical_dir" "Shared Claude + Codex memory for project $project_name"
    fi
  fi

  qmd_cmd "$project_name" update
  if [[ "$skip_embed" != "1" ]]; then
    qmd_cmd "$project_name" embed || true
  fi
}

ensure_project_exists() {
  local project_name="$1"
  local shared_root="$2"
  local shared_project_dir="$shared_root/$project_name"

  # Already set up? Quick exit.
  [[ -d "$shared_project_dir/sessions" ]] && return 0

  # Create directory structure
  safe_mkdir "$shared_project_dir/sessions"
  safe_mkdir "$shared_project_dir/decisions"
  safe_mkdir "$shared_project_dir/patterns"
  safe_mkdir "$shared_project_dir/bugs"
  local qmd_index
  qmd_index="$(qmd_index_name "$project_name")"

  # Create MEMORY.md if missing
  if [[ ! -f "$shared_project_dir/MEMORY.md" ]]; then
    cat >"$shared_project_dir/MEMORY.md" <<EOF
# Shared Memory: $project_name

This directory is shared by Claude Code and Codex through qmd.

## Query
- qmd --index $qmd_index search "query" -c $project_name
- qmd --index $qmd_index vsearch "query" -c $project_name
- qmd --index $qmd_index query "query" -c $project_name

## Write
Add markdown files under:
- sessions/
- decisions/
- patterns/
- bugs/

Then run:
- qmd --index $qmd_index update
- qmd --index $qmd_index embed
EOF
  fi

  # Create symlinks for Claude/Codex knowledge dirs
  link_to_shared "$DEFAULT_CLAUDE_HOME/knowledge/$project_name" "$shared_project_dir"
  link_to_shared "$DEFAULT_CODEX_HOME/knowledge/$project_name" "$shared_project_dir"

  # Register qmd collection (if qmd available)
  if command -v qmd >/dev/null 2>&1; then
    ensure_collection "$(slugify "$project_name")" "$shared_project_dir" "$project_name" "0"
  fi

  echo "Auto-created project: $project_name" >&2
}

write_memory_note() {
  local project_name="$1"
  local shared_root="$2"
  shift 2
  local summary="$*"

  [[ -n "$summary" ]] || die "write requires a summary string"

  local shared_project_dir="$shared_root/$project_name"
  safe_mkdir "$shared_project_dir/sessions"
  safe_mkdir "$shared_project_dir/decisions"
  safe_mkdir "$shared_project_dir/patterns"
  safe_mkdir "$shared_project_dir/bugs"
  local qmd_index
  qmd_index="$(qmd_index_name "$project_name")"

  local date_str mid builder_script build_json session_file promoted_count collection_name
  date_str="$(date +%Y-%m-%d)"
  mid="$(machine_id)"
  builder_script="$(script_dir)/memory_note_builder.py"
  [[ -f "$builder_script" ]] || die "Missing memory note builder: $builder_script"

  if ! build_json="$(python3 "$builder_script" write \
    --project-dir "$shared_project_dir" \
    --project "$project_name" \
    --summary "$summary" \
    --machine "$mid" \
    --date "$date_str")"; then
    die "Failed to build memory note"
  fi

  session_file="$(python3 -c "import json,sys; print(json.load(sys.stdin).get('session_file',''))" <<<"$build_json")"
  promoted_count="$(python3 -c "import json,sys; print(len(json.load(sys.stdin).get('promoted_files', [])))" <<<"$build_json")"
  [[ -n "$session_file" ]] || die "Memory note builder returned no session file"

  collection_name="$(slugify "$project_name")"
  qmd_cmd "$project_name" update
  qmd_cmd "$project_name" embed || true

  echo "Wrote memory: $session_file"
  echo "Promoted durable notes: $promoted_count"
  echo "Collection: $collection_name"
}

cmd_setup() {
  local project_arg=""
  local shared_root="$DEFAULT_SHARED_ROOT"
  local skip_embed="0"
  local dry_run="0"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project)
        project_arg="${2:-}"
        shift 2
        ;;
      --shared-root)
        shared_root="${2:-}"
        shift 2
        ;;
      --skip-embed)
        skip_embed="1"
        shift
        ;;
      --dry-run)
        dry_run="1"
        shift
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        die "Unknown setup option: $1"
        ;;
    esac
  done

  local project_name shared_project_dir
  project_name="$(derive_project_name "$project_arg")"
  shared_root="$(abs_realpath "$shared_root")"
  shared_project_dir="$shared_root/$project_name"

  local claude_project_dir codex_project_dir
  claude_project_dir="$DEFAULT_CLAUDE_HOME/knowledge/$project_name"
  codex_project_dir="$DEFAULT_CODEX_HOME/knowledge/$project_name"

  echo "Project: $project_name"
  echo "Shared memory: $shared_project_dir"
  echo "Claude path: $claude_project_dir"
  echo "Codex path: $codex_project_dir"

  if [[ "$dry_run" == "1" ]]; then
    echo "[dry-run] would create shared directories and link Claude/Codex paths"
    echo "[dry-run] would ensure qmd MCP config in ~/.claude/settings.json and ~/.codex/config.toml"
    echo "[dry-run] would ensure qmd collection + context + update/embed"
    return
  fi

  safe_mkdir "$shared_project_dir"
  safe_mkdir "$shared_project_dir/sessions"
  safe_mkdir "$shared_project_dir/decisions"
  safe_mkdir "$shared_project_dir/patterns"
  safe_mkdir "$shared_project_dir/bugs"

  if [[ ! -f "$shared_project_dir/MEMORY.md" ]]; then
    cat >"$shared_project_dir/MEMORY.md" <<EOF
# Shared Memory: $project_name

This directory is shared by Claude Code and Codex through qmd.

## Query
- qmd --index $qmd_index search "query" -c $project_name
- qmd --index $qmd_index vsearch "query" -c $project_name
- qmd --index $qmd_index query "query" -c $project_name

## Write
Add markdown files under:
- sessions/
- decisions/
- patterns/
- bugs/

Then run:
- qmd --index $qmd_index update
- qmd --index $qmd_index embed
EOF
  fi

  link_to_shared "$claude_project_dir" "$shared_project_dir"
  link_to_shared "$codex_project_dir" "$shared_project_dir"

  ensure_claude_settings "$DEFAULT_CLAUDE_HOME/settings.json"
  ensure_codex_settings "$DEFAULT_CODEX_HOME/config.toml"

  ensure_collection "$(slugify "$project_name")" "$shared_project_dir" "$project_name" "$skip_embed"

  echo "Bridge setup complete."
}

cmd_write() {
  local project_arg=""
  local shared_root="$DEFAULT_SHARED_ROOT"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project)
        project_arg="${2:-}"
        shift 2
        ;;
      --shared-root)
        shared_root="${2:-}"
        shift 2
        ;;
      --help|-h)
        usage
        exit 0
        ;;
      *)
        break
        ;;
    esac
  done

  local project_name summary
  project_name="$(derive_project_name "$project_arg")"
  shared_root="$(abs_realpath "$shared_root")"
  summary="$*"

  # Remote mode: POST to server
  if is_remote_configured; then
    local mid body response
    mid="$(get_machine_id_from_config)"
    [[ -n "$mid" ]] || mid="$(machine_id)"
    body="$(python3 -c "import json,sys; print(json.dumps({'summary':sys.argv[1],'project':sys.argv[2],'machine_id':sys.argv[3]}))" "$summary" "$project_name" "$mid")"
    if response="$(remote_post "/api/v1/write" "$body" 2>/dev/null)"; then
      echo "Memory written to server: $(echo "$response" | python3 -c "import json,sys; print(json.load(sys.stdin).get('file','ok'))" 2>/dev/null || echo "ok")"
      return 0
    fi
    echo "Warning: Server unreachable; falling back to local write." >&2
  fi

  ensure_project_exists "$project_name" "$shared_root"
  write_memory_note "$project_name" "$shared_root" "$summary" || {
    echo "Could not write memory (filesystem may be read-only). Summary not persisted."
    return 0
  }
}

run_cmd_with_timeout() {
  local timeout_seconds="$1"
  shift

  python3 - "$timeout_seconds" "$@" <<'PY'
import subprocess
import sys

timeout_seconds = float(sys.argv[1])
command = sys.argv[2:]

try:
    result = subprocess.run(
        command,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
        timeout=timeout_seconds,
    )
except subprocess.TimeoutExpired:
    sys.stderr.write(f"Command timed out after {int(timeout_seconds)}s: {' '.join(command)}\n")
    raise SystemExit(124)
except Exception:
    raise SystemExit(125)

if result.returncode == 0:
    if result.stdout:
        sys.stdout.write(result.stdout)
    raise SystemExit(0)

raise SystemExit(result.returncode)
PY
}

run_memory_query() {
  local query="$1"
  local collection="${2:-}"
  local project_name="${3:-}"
  local qmd_timeout_seconds="${TOTAL_RECALL_QMD_TIMEOUT_SECONDS:-20}"
  local out=""

  if [[ -n "$collection" ]]; then
    out="$(run_cmd_with_timeout "$qmd_timeout_seconds" qmd --index "$(qmd_index_name "$project_name")" query "$query" -c "$collection" || true)"
    if [[ -n "$out" ]] && [[ "$(count_qmd_entries "$out")" -gt 0 ]]; then
      printf '%s\n' "$out"
      return 0
    fi
    out="$(run_cmd_with_timeout "$qmd_timeout_seconds" qmd --index "$(qmd_index_name "$project_name")" search "$query" -c "$collection" || true)"
    if [[ -n "$out" ]] && [[ "$(count_qmd_entries "$out")" -gt 0 ]]; then
      printf '%s\n' "$out"
      return 0
    fi
  else
    out="$(run_cmd_with_timeout "$qmd_timeout_seconds" qmd --index "$(qmd_index_name "$project_name")" query "$query" || true)"
    if [[ -n "$out" ]] && [[ "$(count_qmd_entries "$out")" -gt 0 ]]; then
      printf '%s\n' "$out"
      return 0
    fi
    out="$(run_cmd_with_timeout "$qmd_timeout_seconds" qmd --index "$(qmd_index_name "$project_name")" search "$query" || true)"
    if [[ -n "$out" ]] && [[ "$(count_qmd_entries "$out")" -gt 0 ]]; then
      printf '%s\n' "$out"
      return 0
    fi
  fi

  return 1
}

count_qmd_entries() {
  python3 - "$1" <<'PY'
import re
import sys

text = sys.argv[1]
print(len(re.findall(r"(?m)^qmd://", text)))
PY
}

run_expanded_memory_query() {
  local query="$1"
  local collection="${2:-}"
  local project_name="${3:-}"
  local min_results="${TOTAL_RECALL_QUERY_MIN_RESULTS:-4}"
  local primary expanded_search expanded_vsearch primary_count

  primary="$(run_memory_query "$query" "$collection" "$project_name" || true)"
  primary_count="$(count_qmd_entries "$primary")"

  if [[ -z "$primary" ]]; then
    echo ""
    return 1
  fi

  if [[ "$primary_count" -ge "$min_results" ]]; then
    printf '%s\n' "$primary"
    return 0
  fi

  expanded_search=""
  expanded_vsearch=""
  if [[ -n "$collection" ]]; then
    expanded_search="$(run_cmd_with_timeout "${TOTAL_RECALL_QMD_TIMEOUT_SECONDS:-20}" qmd --index "$(qmd_index_name "$project_name")" search "$query" -c "$collection" || true)"
    expanded_vsearch="$(run_cmd_with_timeout "${TOTAL_RECALL_QMD_TIMEOUT_SECONDS:-20}" qmd --index "$(qmd_index_name "$project_name")" vsearch "$query" -c "$collection" || true)"
  else
    expanded_search="$(run_cmd_with_timeout "${TOTAL_RECALL_QMD_TIMEOUT_SECONDS:-20}" qmd --index "$(qmd_index_name "$project_name")" search "$query" || true)"
    expanded_vsearch="$(run_cmd_with_timeout "${TOTAL_RECALL_QMD_TIMEOUT_SECONDS:-20}" qmd --index "$(qmd_index_name "$project_name")" vsearch "$query" || true)"
  fi

  printf '%s\n\n%s\n\n%s\n' "$primary" "$expanded_search" "$expanded_vsearch"
}

optimize_memory_output() {
  local query="$1"
  local raw_output="$2"
  local optimizer_script
  optimizer_script="$(script_dir)/memory_query_optimizer.py"

  if [[ ! -f "$optimizer_script" ]]; then
    printf '%s\n' "$raw_output"
    return 0
  fi

  if ! printf '%s\n' "$raw_output" | python3 "$optimizer_script" --query "$query"; then
    printf '%s\n' "$raw_output"
  fi
}

cmd_query() {
  local project_arg=""
  local query=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project)
        project_arg="${2:-}"
        shift 2
        ;;
      --help|-h)
        usage
        exit 0
        ;;
      *)
        query="$*"
        break
        ;;
    esac
  done

  [[ -n "$query" ]] || die "query requires a search string"

  # Remote mode: POST to server
  if is_remote_configured; then
    local project_name body response
    project_name="$(derive_project_name "$project_arg")"
    body="$(python3 -c "import json,sys; print(json.dumps({'query':sys.argv[1],'project':sys.argv[2]}))" "$query" "$project_name")"
    if response="$(remote_post "/api/v1/query" "$body" 2>/dev/null)"; then
      python3 -c "import json,sys; print(json.load(sys.stdin).get('results','No results.'))" <<<"$response"
      return 0
    fi
    echo "Warning: Server unreachable; falling back to local query." >&2
  fi

  if ! command -v qmd >/dev/null 2>&1; then
    echo "No memory available (qmd not installed). Continuing without prior context."
    return 0
  fi

  local project_name collection shared_project_dir
  project_name="$(derive_project_name "$project_arg")"
  collection="$(slugify "$project_name")"
  shared_project_dir="$(abs_realpath "$DEFAULT_SHARED_ROOT")/$project_name"
  local collection_exists="0"
  run_cmd_with_timeout 10 qmd --index "$(qmd_index_name "$project_name")" ls "$collection" >/dev/null 2>&1 && collection_exists="1"
  if [[ "$collection_exists" != "1" && -d "$shared_project_dir" ]]; then
    ensure_collection "$collection" "$shared_project_dir" "$project_name" "1" >/dev/null 2>&1 || true
    run_cmd_with_timeout 10 qmd --index "$(qmd_index_name "$project_name")" ls "$collection" >/dev/null 2>&1 && collection_exists="1"
  fi
  local raw_results=""

  if [[ "$collection_exists" == "1" ]]; then
    raw_results="$(run_expanded_memory_query "$query" "$collection" "$project_name")" || {
      echo "No memory available (qmd query/search failed or timed out). Continuing without prior context."
      return 0
    }
  else
    echo "No memory yet for project '$collection'. Memories will be created after the first write. Continuing without prior context."
    return 0
  fi

  optimize_memory_output "$query" "$raw_results"
}

cmd_status() {
  local project_arg=""
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project)
        project_arg="${2:-}"
        shift 2
        ;;
      --help|-h)
        usage
        exit 0
        ;;
      *)
        die "Unknown status option: $1"
        ;;
    esac
  done

  local project_name
  project_name="$(derive_project_name "$project_arg")"
  local shared_project_dir claude_project_dir codex_project_dir
  shared_project_dir="$(abs_realpath "$DEFAULT_SHARED_ROOT")/$project_name"
  claude_project_dir="$DEFAULT_CLAUDE_HOME/knowledge/$project_name"
  codex_project_dir="$DEFAULT_CODEX_HOME/knowledge/$project_name"

  echo "Project: $project_name"
  echo "Shared: $shared_project_dir"
  if [[ -L "$claude_project_dir" ]]; then
    echo "Claude: $claude_project_dir -> $(readlink "$claude_project_dir")"
  else
    echo "Claude: $claude_project_dir"
  fi
  if [[ -L "$codex_project_dir" ]]; then
    echo "Codex:  $codex_project_dir -> $(readlink "$codex_project_dir")"
  else
    echo "Codex:  $codex_project_dir"
  fi

  if command -v qmd >/dev/null 2>&1; then
    echo ""
    echo "QMD index: $(qmd_index_name "$project_name")"
    qmd_cmd "$project_name" status
  else
    echo "qmd not installed"
  fi
}

cmd_ingest() {
  local project_arg=""
  local shared_root="$DEFAULT_SHARED_ROOT"
  local skip_embed="0"
  local print_json="0"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project)
        project_arg="${2:-}"
        shift 2
        ;;
      --shared-root)
        shared_root="${2:-}"
        shift 2
        ;;
      --skip-embed)
        skip_embed="1"
        shift
        ;;
      --json)
        print_json="1"
        shift
        ;;
      --help|-h)
        usage
        exit 0
        ;;
      *)
        die "Unknown ingest option: $1"
        ;;
    esac
  done

  require_cmd qmd
  require_cmd python3

  local project_name shared_project_dir collection_name state_file script_dir_path ingest_script
  project_name="$(derive_project_name "$project_arg")"
  shared_root="$(abs_realpath "$shared_root")"
  shared_project_dir="$shared_root/$project_name"
  collection_name="$(slugify "$project_name")"
  state_file="$(abs_realpath "$DEFAULT_STATE_ROOT")/$project_name.json"
  script_dir_path="$(script_dir)"
  ingest_script="$script_dir_path/ingest_sessions.py"
  [[ -f "$ingest_script" ]] || die "ingest helper not found: $ingest_script"

  safe_mkdir "$shared_project_dir"
  safe_mkdir "$(dirname "$state_file")"

  if ! qmd_cmd "$project_name" ls "$collection_name" >/dev/null 2>&1; then
    ensure_collection "$collection_name" "$shared_project_dir" "$project_name" "1"
  fi

  local ingest_json
  ingest_json="$(python3 "$ingest_script" \
    --project "$project_name" \
    --shared-root "$shared_root" \
    --state-file "$state_file" \
    --codex-home "$DEFAULT_CODEX_HOME" \
    --claude-home "$DEFAULT_CLAUDE_HOME")"

  local codex_written claude_written total_written
  codex_written="$(python3 -c 'import json,sys; d=json.load(sys.stdin); print(d["codex"]["written"])' <<<"$ingest_json")"
  claude_written="$(python3 -c 'import json,sys; d=json.load(sys.stdin); print(d["claude"]["written"])' <<<"$ingest_json")"
  total_written=$((codex_written + claude_written))

  if (( total_written > 0 )); then
    qmd_cmd "$project_name" update
    if [[ "$skip_embed" != "1" ]]; then
      qmd_cmd "$project_name" embed || true
    fi
  fi

  # Upload newly-imported sessions to remote server if configured
  if is_remote_configured && (( total_written > 0 )); then
    local imported_dir="$shared_project_dir/sessions/imported"
    local mid
    mid="$(get_machine_id_from_config)"
    [[ -n "$mid" ]] || mid="$(machine_id)"

    local files_json
    files_json="$(python3 - "$imported_dir" <<'PY'
import json, os, sys, time
base = sys.argv[1]
cutoff = time.time() - 300  # last 5 minutes
files = []
if os.path.isdir(base):
    for root, dirs, names in os.walk(base):
        for name in names:
            if not name.endswith(".md"):
                continue
            full = os.path.join(root, name)
            if os.path.getmtime(full) >= cutoff:
                rel = os.path.relpath(full, os.path.dirname(base))
                with open(full) as f:
                    content = f.read()
                files.append({"relative_path": rel, "content": content})
print(json.dumps(files))
PY
)"

    if [[ "$files_json" != "[]" ]]; then
      local body
      body="$(python3 -c "import json,sys; print(json.dumps({'project':sys.argv[1],'machine_id':sys.argv[2],'files':json.loads(sys.argv[3])}))" "$project_name" "$mid" "$files_json")"
      if remote_post "/api/v1/ingest-upload" "$body" >/dev/null 2>&1; then
        echo "Uploaded imported sessions to remote server."
      else
        echo "Warning: Could not upload to remote server." >&2
      fi
    fi
  fi

  if [[ "$print_json" == "1" ]]; then
    echo "$ingest_json"
  else
    echo "Ingested project: $project_name"
    echo "Codex sessions imported: $codex_written"
    echo "Claude sessions updated: $claude_written"
    echo "State file: $state_file"
    if (( total_written == 0 )); then
      echo "No new session data found."
    fi
  fi
}

cmd_install() {
  local project_arg=""
  local shared_root="$DEFAULT_SHARED_ROOT"
  local use_icloud="1"
  local icloud_root="$DEFAULT_ICLOUD_ROOT"
  local interval_minutes="$DEFAULT_LAUNCH_INTERVAL_MINUTES"
  local skip_embed="0"
  local no_launch_agent="0"
  local install_mode="standalone"  # standalone | server | client
  local server_url=""
  local api_key=""
  local server_port=""

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project)
        project_arg="${2:-}"
        shift 2
        ;;
      --shared-root)
        shared_root="${2:-}"
        shift 2
        ;;
      --icloud)
        use_icloud="1"
        shift
        ;;
      --no-icloud)
        use_icloud="0"
        shift
        ;;
      --icloud-root)
        icloud_root="${2:-}"
        shift 2
        ;;
      --interval-minutes)
        interval_minutes="${2:-}"
        shift 2
        ;;
      --skip-embed)
        skip_embed="1"
        shift
        ;;
      --no-launch-agent)
        no_launch_agent="1"
        shift
        ;;
      --server)
        install_mode="server"
        shift
        ;;
      --client)
        install_mode="client"
        shift
        ;;
      --server-url)
        server_url="${2:-}"
        shift 2
        ;;
      --api-key)
        api_key="${2:-}"
        shift 2
        ;;
      --port)
        server_port="${2:-}"
        shift 2
        ;;
      --help|-h)
        usage
        exit 0
        ;;
      *)
        die "Unknown install option: $1"
        ;;
    esac
  done

  # Validate mode-specific requirements
  if [[ "$install_mode" == "client" ]]; then
    [[ -n "$server_url" ]] || die "--client requires --server-url URL"
    [[ -n "$api_key" ]] || die "--client requires --api-key KEY"
  fi

  local project_name cli_path
  project_name="$(derive_project_name "$project_arg")"
  cli_path="$(script_path)"

  # Create the stable symlink (needed for all modes)
  safe_mkdir "$HOME/.local/bin"
  ln -sf "$cli_path" "$HOME/.local/bin/total-recall"
  local canonical_path
  canonical_path="$(canonical_cli_path)"

  if [[ "$install_mode" == "client" ]]; then
    # --- Client-only install: no local qmd, no local dirs ---
    echo "Installing in client mode..."
    echo "Project: $project_name"

    # Configure the client connection
    "$cli_path" client configure --server-url "$server_url" --api-key "$api_key"

    # Inject instruction blocks (uses canonical path for stability)
    install_instruction_blocks "$project_name" "$shared_root" "$canonical_path"

    echo ""
    echo "Client install complete."
    echo "  Project:    $project_name"
    echo "  Server:     $server_url"
    echo "  CLI link:   $canonical_path"
    echo "  Web UI:     $server_url/"
    echo ""
    echo "All write/query operations route to the server."
    echo "Claude hooks and Codex AGENTS instructions are active — memory query at session start, write at session end."
    return 0
  fi

  # --- Standalone or Server mode: full local setup ---
  [[ "$interval_minutes" =~ ^[0-9]+$ ]] || die "--interval-minutes must be a number"
  (( interval_minutes >= 1 )) || die "--interval-minutes must be >= 1"

  shared_root="$(abs_realpath "$shared_root")"

  "$cli_path" setup --project "$project_name" --shared-root "$shared_root" --skip-embed

  if [[ "$use_icloud" == "1" ]]; then
    "$cli_path" icloud-enable --project "$project_name" --shared-root "$shared_root" --icloud-root "$icloud_root" --skip-embed
  fi

  if [[ "$skip_embed" == "1" ]]; then
    "$cli_path" ingest --project "$project_name" --shared-root "$shared_root" --skip-embed
  else
    "$cli_path" ingest --project "$project_name" --shared-root "$shared_root"
  fi

  install_instruction_blocks "$project_name" "$shared_root" "$canonical_path"

  if [[ "$no_launch_agent" != "1" ]]; then
    install_launch_agent "$project_name" "$shared_root" "$canonical_path" "$interval_minutes"
  fi

  echo ""
  echo "Install complete."
  echo "Project: $project_name"
  echo "CLI link: $canonical_path"

  if [[ "$install_mode" == "server" ]]; then
    # --- Server mode: also init + launchd ---
    echo ""
    echo "Setting up server..."

    # Only init if not already configured
    local config_path="$HOME/.ai-memory/server.json"
    if [[ ! -f "$config_path" ]]; then
      "$cli_path" server init
    else
      echo "Server already initialized (using existing config)."
    fi

    # Apply custom port if specified
    if [[ -n "$server_port" ]]; then
      python3 - "$config_path" "$server_port" <<'PY'
import json, sys
path, port = sys.argv[1], int(sys.argv[2])
with open(path) as f:
    config = json.load(f)
config["port"] = port
with open(path, "w") as f:
    json.dump(config, f, indent=2)
    f.write("\n")
print(f"Server port set to {port}")
PY
    fi

    # Install launchd agent (keeps server running across reboots)
    "$cli_path" server install-launchd

    # Read the config to show connection info
    local port api_key_display
    port="$(python3 -c "import json; print(json.load(open('$config_path')).get('port', 7899))")"
    api_key_display="$(python3 -c "import json; keys=json.load(open('$config_path')).get('api_keys',[]); print(keys[0] if keys else 'none')")"

    echo ""
    echo "=== Server ready ==="
    echo "  API:     http://0.0.0.0:$port/api/v1/"
    echo "  Web UI:  http://0.0.0.0:$port/"
    echo "  API key: $api_key_display"
    echo ""
    echo "On other machines, run:"
    echo "  total-recall install --project $project_name --client \\"
    echo "    --server-url http://<this-machine>:$port \\"
    echo "    --api-key $api_key_display"
  fi
}

cmd_icloud_enable() {
  local project_arg=""
  local shared_root="$DEFAULT_SHARED_ROOT"
  local icloud_root="$DEFAULT_ICLOUD_ROOT"
  local skip_embed="0"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project)
        project_arg="${2:-}"
        shift 2
        ;;
      --shared-root)
        shared_root="${2:-}"
        shift 2
        ;;
      --icloud-root)
        icloud_root="${2:-}"
        shift 2
        ;;
      --skip-embed)
        skip_embed="1"
        shift
        ;;
      --help|-h)
        usage
        exit 0
        ;;
      *)
        die "Unknown icloud-enable option: $1"
        ;;
    esac
  done

  require_icloud_drive

  local project_name local_project cloud_project
  project_name="$(derive_project_name "$project_arg")"
  shared_root="$(abs_realpath "$shared_root")"
  icloud_root="$(abs_realpath "$icloud_root")"
  local_project="$shared_root/$project_name"
  cloud_project="$icloud_root/$project_name"

  echo "Project: $project_name"
  echo "Local shared path: $local_project"
  echo "iCloud path: $cloud_project"

  safe_mkdir "$shared_root"
  safe_mkdir "$icloud_root"
  safe_mkdir "$cloud_project"

  if [[ ! -e "$local_project" ]]; then
    safe_mkdir "$local_project"
    safe_mkdir "$local_project/sessions"
    safe_mkdir "$local_project/decisions"
    safe_mkdir "$local_project/patterns"
    safe_mkdir "$local_project/bugs"
  fi

  if [[ -d "$local_project" && ! -L "$local_project" ]]; then
    sync_dirs_ignore_existing "$local_project" "$cloud_project"
    sync_dirs_ignore_existing "$cloud_project" "$local_project"
    local backup
    backup="$(backup_name "$local_project")"
    mv "$local_project" "$backup"
    echo "Backed up local project dir -> $backup"
    ln -s "$cloud_project" "$local_project"
  elif [[ -L "$local_project" ]]; then
    local resolved_current resolved_cloud
    resolved_current="$(resolve_link_target "$local_project")"
    resolved_cloud="$(abs_realpath "$cloud_project")"
    if [[ "$resolved_current" != "$resolved_cloud" ]]; then
      rm -f "$local_project"
      ln -s "$cloud_project" "$local_project"
    fi
  else
    ln -s "$cloud_project" "$local_project"
  fi

  local claude_project_dir codex_project_dir
  claude_project_dir="$DEFAULT_CLAUDE_HOME/knowledge/$project_name"
  codex_project_dir="$DEFAULT_CODEX_HOME/knowledge/$project_name"
  link_to_shared "$claude_project_dir" "$local_project"
  link_to_shared "$codex_project_dir" "$local_project"

  ensure_collection "$(slugify "$project_name")" "$local_project" "$project_name" "$skip_embed"

  echo "iCloud live backup enabled."
}

cmd_icloud_sync() {
  local project_arg=""
  local shared_root="$DEFAULT_SHARED_ROOT"
  local icloud_root="$DEFAULT_ICLOUD_ROOT"
  local direction="both"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project)
        project_arg="${2:-}"
        shift 2
        ;;
      --shared-root)
        shared_root="${2:-}"
        shift 2
        ;;
      --icloud-root)
        icloud_root="${2:-}"
        shift 2
        ;;
      --direction)
        direction="${2:-}"
        shift 2
        ;;
      --help|-h)
        usage
        exit 0
        ;;
      *)
        die "Unknown icloud-sync option: $1"
        ;;
    esac
  done

  case "$direction" in
    push|pull|both) ;;
    *) die "--direction must be push, pull, or both" ;;
  esac

  require_icloud_drive

  local project_name local_project cloud_project
  project_name="$(derive_project_name "$project_arg")"
  shared_root="$(abs_realpath "$shared_root")"
  icloud_root="$(abs_realpath "$icloud_root")"
  local_project="$shared_root/$project_name"
  cloud_project="$icloud_root/$project_name"

  [[ -d "$local_project" || -L "$local_project" ]] || die "Local shared project not found: $local_project"
  [[ -d "$cloud_project" ]] || safe_mkdir "$cloud_project"

  if [[ "$direction" == "push" || "$direction" == "both" ]]; then
    sync_dirs_mirror "$local_project" "$cloud_project"
  fi
  if [[ "$direction" == "pull" || "$direction" == "both" ]]; then
    sync_dirs_mirror "$cloud_project" "$local_project"
  fi

  qmd_cmd "$project_name" update
  echo "iCloud sync complete ($direction)."
}

cmd_icloud_status() {
  local project_arg=""
  local shared_root="$DEFAULT_SHARED_ROOT"
  local icloud_root="$DEFAULT_ICLOUD_ROOT"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project)
        project_arg="${2:-}"
        shift 2
        ;;
      --shared-root)
        shared_root="${2:-}"
        shift 2
        ;;
      --icloud-root)
        icloud_root="${2:-}"
        shift 2
        ;;
      --help|-h)
        usage
        exit 0
        ;;
      *)
        die "Unknown icloud-status option: $1"
        ;;
    esac
  done

  local project_name local_project cloud_project
  project_name="$(derive_project_name "$project_arg")"
  shared_root="$(abs_realpath "$shared_root")"
  icloud_root="$(abs_realpath "$icloud_root")"
  local_project="$shared_root/$project_name"
  cloud_project="$icloud_root/$project_name"

  echo "Project: $project_name"
  echo "Local shared: $local_project"
  if [[ -L "$local_project" ]]; then
    echo "Local shared link target: $(resolve_link_target "$local_project")"
  fi
  echo "iCloud: $cloud_project"

  if [[ -d "$local_project" || -L "$local_project" ]]; then
    echo "Local files: $(find -L "$local_project" -type f 2>/dev/null | wc -l | tr -d ' ')"
  else
    echo "Local files: path missing"
  fi
  if [[ -d "$cloud_project" ]]; then
    echo "iCloud files: $(find "$cloud_project" -type f 2>/dev/null | wc -l | tr -d ' ')"
  else
    echo "iCloud files: path missing"
  fi
}

cmd_server() {
  local subcmd="${1:-}"
  shift || true

  local server_script
  server_script="$(script_dir)/total-recall-server"
  local config_path="$HOME/.ai-memory/server.json"
  local pid_file="$HOME/.ai-memory/server.pid"
  local log_dir="$HOME/.ai-memory/logs"

  case "$subcmd" in
    init)
      safe_mkdir "$(dirname "$config_path")"
      local api_key
      api_key="$(python3 -c "import secrets; print('tr_sk_' + secrets.token_hex(24))")"
      python3 - "$config_path" "$api_key" <<'PY'
import json, sys
path, key = sys.argv[1], sys.argv[2]
config = {"port": 7899, "api_keys": [key], "shared_root": "~/.ai-memory/knowledge", "bind_address": "0.0.0.0"}
with open(path, "w") as f:
    json.dump(config, f, indent=2)
    f.write("\n")
print(f"Server config written to {path}")
print(f"API key: {key}")
print(f"Share this key with clients for authentication.")
PY
      ;;

    start)
      [[ -f "$config_path" ]] || die "No server config. Run: total-recall server init"
      [[ -f "$server_script" ]] || die "Server script not found: $server_script"
      safe_mkdir "$log_dir"

      if [[ -f "$pid_file" ]] && kill -0 "$(cat "$pid_file")" 2>/dev/null; then
        echo "Server already running (PID $(cat "$pid_file"))"
        return 0
      fi

      nohup python3 "$server_script" --config "$config_path" \
        >"$log_dir/server.out.log" 2>"$log_dir/server.err.log" &
      local pid=$!
      echo "$pid" > "$pid_file"
      sleep 1
      if kill -0 "$pid" 2>/dev/null; then
        echo "Server started (PID $pid)"
        local port
        port="$(python3 -c "import json; print(json.load(open('$config_path')).get('port', 7899))")"
        echo "Listening on port $port"
      else
        echo "Server failed to start. Check $log_dir/server.err.log"
        rm -f "$pid_file"
        return 1
      fi
      ;;

    stop)
      if [[ -f "$pid_file" ]]; then
        local pid
        pid="$(cat "$pid_file")"
        if kill -0 "$pid" 2>/dev/null; then
          kill "$pid"
          echo "Server stopped (PID $pid)"
        else
          echo "Server not running (stale PID file)"
        fi
        rm -f "$pid_file"
      else
        echo "No PID file found. Server may not be running."
      fi
      ;;

    status)
      if [[ -f "$pid_file" ]] && kill -0 "$(cat "$pid_file")" 2>/dev/null; then
        echo "Server running (PID $(cat "$pid_file"))"
        if [[ -f "$config_path" ]]; then
          local port
          port="$(python3 -c "import json; print(json.load(open('$config_path')).get('port', 7899))")"
          echo "Port: $port"
          curl -sf "http://127.0.0.1:$port/api/v1/status" 2>/dev/null \
            | python3 -m json.tool 2>/dev/null \
            || echo "(could not reach status endpoint)"
        fi
      else
        echo "Server not running."
      fi
      ;;

    add-key)
      [[ -f "$config_path" ]] || die "No server config. Run: total-recall server init"
      python3 - "$config_path" <<'PY'
import json, secrets, sys
path = sys.argv[1]
with open(path) as f:
    config = json.load(f)
key = "tr_sk_" + secrets.token_hex(24)
config.setdefault("api_keys", []).append(key)
with open(path, "w") as f:
    json.dump(config, f, indent=2)
    f.write("\n")
print(f"New API key: {key}")
PY
      ;;

    install-launchd)
      [[ -f "$config_path" ]] || die "No server config. Run: total-recall server init"
      [[ -f "$server_script" ]] || die "Server script not found: $server_script"
      local label="com.totalrecall.server"
      local plist="$HOME/Library/LaunchAgents/$label.plist"
      safe_mkdir "$log_dir"
      safe_mkdir "$HOME/Library/LaunchAgents"

      python3 - "$plist" "$server_script" "$config_path" "$log_dir" <<'PY'
import plistlib, sys
from pathlib import Path

plist_path, server_script, config_path, log_dir = sys.argv[1:]
cmd = (
    'export PATH="$HOME/.bun/bin:/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"; '
    f'exec python3 "{server_script}" --config "{config_path}"'
)
payload = {
    "Label": "com.totalrecall.server",
    "ProgramArguments": ["/bin/bash", "-lc", cmd],
    "RunAtLoad": True,
    "KeepAlive": True,
    "StandardOutPath": f"{log_dir}/server.out.log",
    "StandardErrorPath": f"{log_dir}/server.err.log",
    "ProcessType": "Background",
}
Path(plist_path).parent.mkdir(parents=True, exist_ok=True)
with open(plist_path, "wb") as f:
    plistlib.dump(payload, f)
print(f"LaunchAgent written to {plist_path}")
PY

      local uid
      uid="$(id -u)"
      launchctl bootout "gui/$uid/$label" >/dev/null 2>&1 || true
      if ! launchctl bootstrap "gui/$uid" "$plist" >/dev/null 2>&1; then
        launchctl load -w "$plist" >/dev/null 2>&1 || true
      fi
      echo "Server LaunchAgent installed and started."
      ;;

    *)
      echo "Usage: total-recall server {init|start|stop|status|add-key|install-launchd}"
      ;;
  esac
}

cmd_client() {
  local subcmd="${1:-}"
  shift || true

  local config_path="$HOME/.ai-memory/client.json"

  case "$subcmd" in
    configure)
      local server_url="" api_key=""
      while [[ $# -gt 0 ]]; do
        case "$1" in
          --server-url) server_url="$2"; shift 2 ;;
          --api-key) api_key="$2"; shift 2 ;;
          *) die "Unknown option: $1" ;;
        esac
      done

      [[ -n "$server_url" ]] || die "Usage: total-recall client configure --server-url URL --api-key KEY"
      [[ -n "$api_key" ]] || die "Usage: total-recall client configure --server-url URL --api-key KEY"

      local mid
      mid="$(machine_id)"
      safe_mkdir "$(dirname "$config_path")"
      python3 - "$config_path" "$server_url" "$api_key" "$mid" <<'PY'
import json, sys
path, url, key, mid = sys.argv[1:]
config = {"server_url": url.rstrip("/"), "api_key": key, "machine_id": mid}
with open(path, "w") as f:
    json.dump(config, f, indent=2)
    f.write("\n")
print(f"Client configured.")
print(f"  Server: {url}")
print(f"  Machine: {mid}")
PY
      ;;

    status)
      if [[ ! -f "$config_path" ]]; then
        echo "No client config. Running in local mode."
        echo "Machine: $(machine_id)"
        return 0
      fi
      python3 - "$config_path" <<'PY'
import json, sys
with open(sys.argv[1]) as f:
    config = json.load(f)
print(f"Server URL: {config.get('server_url', 'not set')}")
print(f"Machine ID: {config.get('machine_id', 'not set')}")
print(f"API key:    {config.get('api_key', '')[:12]}...")
PY
      local url
      url="$(get_remote_url)"
      if curl -sf --max-time 3 "${url}/api/v1/status" >/dev/null 2>&1; then
        echo "Server:     reachable"
      else
        echo "Server:     unreachable"
      fi
      ;;

    disable)
      if [[ -f "$config_path" ]]; then
        mv "$config_path" "${config_path}.disabled"
        echo "Client mode disabled. Using local mode."
      else
        echo "Already in local mode."
      fi
      ;;

    enable)
      if [[ -f "${config_path}.disabled" ]]; then
        mv "${config_path}.disabled" "$config_path"
        echo "Client mode re-enabled."
      else
        echo "No disabled config found. Run: total-recall client configure --server-url URL --api-key KEY"
      fi
      ;;

    *)
      echo "Usage: total-recall client {configure --server-url URL --api-key KEY|status|disable|enable}"
      ;;
  esac
}

main() {
  local cmd="${1:-}"
  if [[ -z "$cmd" ]]; then
    usage
    exit 1
  fi
  shift || true

  case "$cmd" in
    setup) cmd_setup "$@" ;;
    write) cmd_write "$@" ;;
    query) cmd_query "$@" ;;
    status) cmd_status "$@" ;;
    ingest) cmd_ingest "$@" ;;
    install) cmd_install "$@" ;;
    icloud-enable) cmd_icloud_enable "$@" ;;
    icloud-sync) cmd_icloud_sync "$@" ;;
    icloud-status) cmd_icloud_status "$@" ;;
    server) cmd_server "$@" ;;
    client) cmd_client "$@" ;;
    -h|--help|help) usage ;;
    *) die "Unknown command: $cmd" ;;
  esac
}

main "$@"
